Return-Path: <linux-pwm-owner@vger.kernel.org>
X-Original-To: lists+linux-pwm@lfdr.de
Delivered-To: lists+linux-pwm@lfdr.de
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.lfdr.de (Postfix) with ESMTP id 82DB328EC5
	for <lists+linux-pwm@lfdr.de>; Fri, 24 May 2019 03:22:02 +0200 (CEST)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S2388560AbfEXBVJ (ORCPT <rfc822;lists+linux-pwm@lfdr.de>);
        Thu, 23 May 2019 21:21:09 -0400
Received: from relmlor2.renesas.com ([210.160.252.172]:62518 "EHLO
        relmlie6.idc.renesas.com" rhost-flags-OK-OK-OK-FAIL)
        by vger.kernel.org with ESMTP id S2388141AbfEXBVJ (ORCPT
        <rfc822;linux-pwm@vger.kernel.org>); Thu, 23 May 2019 21:21:09 -0400
Date:   24 May 2019 10:21:06 +0900
X-IronPort-AV: E=Sophos;i="5.60,505,1549897200"; 
   d="scan'208";a="16606331"
Received: from unknown (HELO relmlir5.idc.renesas.com) ([10.200.68.151])
  by relmlie6.idc.renesas.com with ESMTP; 24 May 2019 10:21:06 +0900
Received: from morimoto-PC.renesas.com (unknown [10.166.18.140])
        by relmlir5.idc.renesas.com (Postfix) with ESMTP id ADD8D400A700;
        Fri, 24 May 2019 10:21:06 +0900 (JST)
Message-ID: <87k1egr78w.wl-kuninori.morimoto.gx@renesas.com>
From:   Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
To:     Cao Van Dong <cv-dong@jinso.co.jp>
Cc:     <linux-renesas-soc@vger.kernel.org>, <thierry.reding@gmail.com>,
        <horms+renesas@verge.net.au>, <geert+renesas@glider.be>,
        <broonie@kernel.org>, <linux-pwm@vger.kernel.org>,
        <yoshihiro.shimoda.uh@renesas.com>, <h-inayoshi@jinso.co.jp>,
        <na-hoan@jinso.co.jp>
Subject: Re: [PATCH v3] pwm: renesas-tpu: Add suspend/resume function
In-Reply-To: <1558659389-4397-1-git-send-email-cv-dong@jinso.co.jp>
References: <1558659389-4397-1-git-send-email-cv-dong@jinso.co.jp>
User-Agent: Wanderlust/2.15.9 Emacs/24.5 Mule/6.0
MIME-Version: 1.0 (generated by SEMI-EPG 1.14.7 - "Harue")
Content-Type: text/plain; charset=US-ASCII
Sender: linux-pwm-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-pwm.vger.kernel.org>
X-Mailing-List: linux-pwm@vger.kernel.org


Hi Cao

If you post v3 patches, you should post whole series

> This patch adds suspend/resume function support for Renesas the 16-Bit Timer
> Pulse Unit (TPU) driver. This has been tested on the Salvator-XS board 
> with R-Car M3-N and H3 at renesas-drivers-2019-05-21-v5.2-rc1 tag.
> I expect this to work on other SoCs.
> 
> Test procedure:
>   - Enable TPU and pin control in DTS.
>   - Make sure switches { SW29-[1-2] are switched off or 
>     SW31-[1-4] are switched off(only for Salvator-xs) }.
>   - Exercise userspace PWM control for pwm[2,3] 
>     of /sys/class/pwm/pwmchip1/ .
>   - Inspect PWM signals on the input side of { CN29-[58,60] 
>     or SW31-[1,2] (only for Salvator-xs) }
>     before and after suspend/resume using an oscilloscope. 
> 
> Signed-off-by: Cao Van Dong <cv-dong@jinso.co.jp>
> Tested-by: Cao Van Dong <cv-dong@jinso.co.jp>
> Acked-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>

Drop my name from here, I'm not Acked yet.

> +#ifdef CONFIG_PM_SLEEP
> +static int tpu_pwm_restart_timer(struct pwm_device *pwm)
> +{
> +	if (!test_bit(PWMF_REQUESTED, &pwm->flags))
> +		return 0;
> +
> +	/* Restart timer */
> +	tpu_pwm_disable(pwm->chip,pwm);
> +	tpu_pwm_enable(pwm->chip,pwm);
> +
> +	return 0;
> +}
> +
> +static int tpu_pwm_suspend(struct device *dev)
> +{
> +	struct tpu_device *tpu = dev_get_drvdata(dev);
> +	struct pwm_chip *chip = &tpu->chip;
> +	struct pwm_device *pwm;
> +	int i;
> +
> +	for (i = 0; i < TPU_CHANNEL_MAX; i++) {
> +		if ((pwm_get_chip_data(&chip->pwms[i])) != NULL) {
> +			pwm = &chip->pwms[i];
> +			if (!test_bit(PWMF_REQUESTED, &pwm->flags))
> +				return 0;
> +		}
> +	}
> +
> +	return 0;
> +}
> +
> +static int tpu_pwm_resume(struct device *dev)
> +{
> +	struct tpu_device *tpu = dev_get_drvdata(dev);
> +	struct pwm_chip *chip = &tpu->chip;
> +	struct pwm_device *pwm;
> +	int i;
> +
> +	pm_runtime_get_sync(dev);
> +
> +	for (i = 0; i < TPU_CHANNEL_MAX; i++) {
> +		if ((pwm_get_chip_data(&chip->pwms[i])) != NULL) {
> +			pwm = &chip->pwms[i];
> +			tpu_pwm_restart_timer(pwm);
> +		}
> +	}
> +
> +	return 0;
> +}
> +#endif /* CONFIG_PM_SLEEP */

again

	pwm = &chip->pwms[i];
	if (pwm_get_chip_data(pwms)) {

Why you "restart" at resume ?
I think "disable" at suspend, and "enable" at resume is generic ?

You call pm_runtime_get_sync() at resume,
but removed pm_runtime_put() suspend ??

Thank you for your help !!
Best regards
---
Kuninori Morimoto
